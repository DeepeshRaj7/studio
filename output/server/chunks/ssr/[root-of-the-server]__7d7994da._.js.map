{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-recipe.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview Recipe generation flow based on available ingredients.\n *\n * - generateRecipe - A function that generates a recipe based on ingredients.\n * - GenerateRecipeInput - The input type for the generateRecipe function.\n * - GenerateRecipeOutput - The return type for the generateRecipe function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst GenerateRecipeInputSchema = z.object({\n  ingredients: z\n    .string()\n    .describe('A comma separated list of ingredients to use in the recipe.'),\n  previousRecipeTitle: z.string().optional().describe('The title of the previously generated recipe, to avoid duplicates.'),\n  servings: z.number().optional().describe('The number of people to cook for.'),\n  dietaryRestrictions: z.array(z.string()).optional().describe('A list of dietary restrictions to apply, e.g., \"Vegan\", \"Gluten-Free\".'),\n  cuisine: z.string().optional().describe('The desired cuisine style for the recipe, e.g., \"Italian\", \"Mexican\".'),\n});\nexport type GenerateRecipeInput = z.infer<typeof GenerateRecipeInputSchema>;\n\nconst GenerateRecipeOutputSchema = z.object({\n  title: z.string().describe('The title of the recipe.'),\n  cookingTime: z.string().describe('The estimated cooking time in minutes. e.g., \"30-45 minutes\"'),\n  ingredients: z.string().describe('The ingredients required for the recipe.'),\n  instructions: z.string().describe('The instructions for the recipe.'),\n  chefCommentary: z.string().describe('A short, encouraging, and impressive sentence from the chef about the dish.'),\n  imageUrls: z.array(z.string().url()).describe('URLs of images of the dish.'),\n  imageDataUris: z.array(z.string()).optional().describe('Base64 encoded image data URIs.'),\n});\nexport type GenerateRecipeOutput = z.infer<typeof GenerateRecipeOutputSchema>;\n\nexport async function generateRecipe(input: GenerateRecipeInput): Promise<GenerateRecipeOutput> {\n  return generateRecipeFlow(input);\n}\n\nconst recipePrompt = ai.definePrompt({\n  name: 'generateRecipePrompt',\n  input: {schema: GenerateRecipeInputSchema},\n  output: {schema: z.object({\n    title: z.string().describe('The title of the recipe.'),\n    cookingTime: z.string().describe('The estimated cooking time in minutes. e.g., \"30-45 minutes\"'),\n    ingredients: z.string().describe('The ingredients required for the recipe, with measurements.'),\n    instructions: z.string().describe('The instructions for the recipe.'),\n    chefCommentary: z.string().describe('A short, encouraging, and impressive sentence from the chef about the dish. For example: \"You are about to have a wonderful meal!\"'),\n  })},\n  prompt: `You are a world-class chef. Generate a recipe based on the ingredients provided.\n\n  Ingredients: {{{ingredients}}}\n\n  {{#if servings}}\n  The recipe should be for {{{servings}}} people. Please adjust ingredient quantities accordingly.\n  {{/if}}\n\n  {{#if cuisine}}\n  The recipe should be in the style of {{{cuisine}}} cuisine.\n  {{/if}}\n  \n  {{#if dietaryRestrictions.length}}\n  Important: The recipe must adhere to the following dietary restrictions: {{#each dietaryRestrictions}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}. If any of the provided ingredients conflict with these restrictions, please ignore the conflicting ingredients and create a valid recipe.\n  {{/if}}\n\n  {{#if previousRecipeTitle}}\n  Please generate a different recipe than \"{{{previousRecipeTitle}}}\".\n  {{/if}}\n\n  Also provide the estimated cooking time and a short, single sentence of impressive commentary about the final dish.\n\n  Format the response as follows:\n\n  Title: [Recipe Title]\n  Cooking Time: [e.g., 25-30 minutes]\n  Ingredients: [Comma separated list of ingredients with quantities]\n  Instructions: [Step-by-step instructions]\n  Chef's Commentary: [An impressive sentence about the dish]`,\n});\n\n\nconst generateRecipeFlow = ai.defineFlow(\n  {\n    name: 'generateRecipeFlow',\n    inputSchema: GenerateRecipeInputSchema,\n    outputSchema: GenerateRecipeOutputSchema,\n  },\n  async input => {\n    // If cuisine is 'Any', remove it so it's not passed to the prompt\n    if (input.cuisine === 'Any') {\n        input.cuisine = undefined;\n    }\n    const {output: recipeDetails} = await recipePrompt(input);\n    if (!recipeDetails) {\n        throw new Error('Failed to generate recipe details.');\n    }\n\n    const imageUrls: string[] = [];\n    \n    const imagePrompts = [\n        `A cute, simple, and neat photorealistic image of a dish called \"${recipeDetails.title}\". The main ingredients are ${recipeDetails.ingredients}. The dish should be professionally plated on a clean, modern background.`,\n        `Another angle of the dish \"${recipeDetails.title}\" with ingredients ${recipeDetails.ingredients}. This is a simple and cute photo with a shallow depth of field, making the food look very appealing.`,\n        `A top-down, flat-lay photograph of the finished dish \"${recipeDetails.title}\". The plating is neat and artistic. The style is cute and minimalist.`\n    ];\n\n    try {\n        const imagePromises = imagePrompts.map(prompt => \n            ai.generate({\n                model: 'googleai/gemini-2.0-flash-preview-image-generation',\n                prompt: prompt,\n                config: {\n                    responseModalities: ['IMAGE', 'TEXT'],\n                },\n            })\n        );\n        \n        const results = await Promise.allSettled(imagePromises);\n\n        results.forEach(result => {\n            if (result.status === 'fulfilled' && result.value.media && result.value.media.url) {\n                imageUrls.push(result.value.media.url);\n            } else {\n                console.error(\"Image generation failed for one prompt, using placeholder.\", result.status === 'rejected' ? result.reason : 'No media url');\n                imageUrls.push(`https://placehold.co/600x400.png`);\n            }\n        });\n\n    } catch (e) {\n        console.error(\"Image generation failed, using placeholders.\", e);\n        // Fill with placeholders if the whole process fails\n        while (imageUrls.length < 3) {\n            imageUrls.push(`https://placehold.co/600x400.png`);\n        }\n    }\n    \n    // Ensure there are always 3 images, even if some failed.\n    while (imageUrls.length < 3) {\n        imageUrls.push(`https://placehold.co/600x400.png`);\n    }\n\n    return {\n        ...recipeDetails,\n        imageUrls: imageUrls,\n        imageDataUris: [], // Do not send back image data uris\n    };\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 377, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {generateRecipe as '40db2015e9373136ee507b317c411cb2d274c71136'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 429, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}